/**
 * State Management for Telemeister CLI
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import ejs from 'ejs';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Paths are relative to project CWD (where the bot project is)
function getProjectPaths(cwd: string) {
  return {
    srcDir: path.join(cwd, 'src'),
    docDir: path.join(cwd, 'doc'),
    handlersDir: path.join(cwd, 'src', 'handlers'),
    botJsonPath: path.join(cwd, 'bot.json'),
    stateTypesPath: path.join(cwd, 'src', 'bot-state-types.ts'),
    botDiagramMdPath: path.join(cwd, 'doc', 'bot-diagram.md'),
    botDiagramPngPath: path.join(cwd, 'doc', 'bot-diagram.png'),
    // Templates are relative to the package root, not the CLI file
    templatePath: path.join(__dirname, '..', 'templates', 'handler.ts.ejs'),
  };
}

type BotConfig = Record<string, string[]>;

function loadBotConfig(cwd: string): BotConfig {
  const paths = getProjectPaths(cwd);
  if (!fs.existsSync(paths.botJsonPath)) {
    return {};
  }
  return JSON.parse(fs.readFileSync(paths.botJsonPath, 'utf-8'));
}

function saveBotConfig(config: BotConfig, cwd: string): void {
  const paths = getProjectPaths(cwd);
  fs.writeFileSync(paths.botJsonPath, JSON.stringify(config, null, 2) + '\n');
}

function validateStateName(name: string): boolean {
  return /^[a-zA-Z][a-zA-Z0-9_]*$/.test(name);
}

function pascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function getHandlerPath(stateName: string, cwd: string): string {
  return path.join(getProjectPaths(cwd).handlersDir, stateName, 'index.ts');
}

function handlerExists(stateName: string, cwd: string): boolean {
  return fs.existsSync(getHandlerPath(stateName, cwd));
}

function isHandlerFolderNonEmpty(stateName: string, cwd: string): boolean {
  const handlerDir = path.join(getProjectPaths(cwd).handlersDir, stateName);
  if (!fs.existsSync(handlerDir)) return false;
  const files = fs.readdirSync(handlerDir);
  return files.length > 0;
}

function getIncomingTransitions(config: BotConfig, stateName: string): string[] {
  const incoming: string[] = [];
  for (const [from, targets] of Object.entries(config)) {
    if (targets.includes(stateName)) {
      incoming.push(from);
    }
  }
  return incoming;
}

function generateTypes(config: BotConfig): string {
  const states = Object.keys(config).sort();

  if (states.length === 0) {
    return `// Auto-generated by telemeister state:sync - DO NOT EDIT
// No states defined yet

export type AppStates = never;

export type StateTransitions = Record<string, never>;
`;
  }

  const statesUnion = states.map((s) => `'${s}'`).join(' | ');

  let stateTransitionsContent = '';
  for (const state of states) {
    const targets = config[state] || [];
    if (targets.length === 0) {
      stateTransitionsContent += `  ${state}: void;\n`;
    } else {
      const targetsUnion = [...targets]
        .sort()
        .map((t) => `'${t}'`)
        .join(' | ');
      stateTransitionsContent += `  ${state}: ${targetsUnion} | void;\n`;
    }
  }

  let returnTypesContent = '';
  for (const state of states) {
    const typeName = `${pascalCase(state)}Transitions`;
    returnTypesContent += `export type ${typeName} = Promise<StateTransitions['${state}']>;\n`;
  }

  return `// Auto-generated by telemeister state:sync - DO NOT EDIT

export type AppStates = ${statesUnion};

export type StateTransitions = {
${stateTransitionsContent}};

${returnTypesContent}
`;
}

function generateMermaidDiagram(config: BotConfig): string {
  const states = Object.keys(config);

  if (states.length === 0) {
    return 'stateDiagram-v2\n    [*] --> [*]';
  }

  const transitions: string[] = [];
  for (const [from, targets] of Object.entries(config)) {
    for (const to of targets) {
      transitions.push(`    ${from} --> ${to}`);
    }
  }

  return `stateDiagram-v2\n${transitions.join('\n')}`;
}

function generateMermaidMarkdown(config: BotConfig): string {
  const mermaidCode = generateMermaidDiagram(config);

  return `# Bot State Diagram

\`\`\`mermaid
${mermaidCode}
\`\`\`
`;
}

async function generateDiagram(config: BotConfig, cwd: string): Promise<void> {
  const paths = getProjectPaths(cwd);

  // Ensure doc directory exists
  if (!fs.existsSync(paths.docDir)) {
    fs.mkdirSync(paths.docDir, { recursive: true });
  }

  const mdContent = generateMermaidMarkdown(config);
  fs.writeFileSync(paths.botDiagramMdPath, mdContent);
  console.log(`üìù Updated: doc/bot-diagram.md`);

  const mermaidCode = generateMermaidDiagram(config);
  const tempMmdPath = path.join(cwd, '.temp-diagram.mmd');

  fs.writeFileSync(tempMmdPath, mermaidCode);

  try {
    const { execSync } = await import('child_process');
    execSync(`npx mmdc -i "${tempMmdPath}" -o "${paths.botDiagramPngPath}" -b white`, {
      stdio: 'pipe',
      cwd: cwd,
    });
    console.log(`üìù Updated: doc/bot-diagram.png`);
  } catch {
    console.warn(`‚ö†Ô∏è  Could not generate PNG diagram (mermaid-cli may not be installed)`);
  } finally {
    fs.unlinkSync(tempMmdPath);
  }
}

async function createHandler(
  stateName: string,
  transitionStates: string[],
  cwd: string
): Promise<void> {
  const paths = getProjectPaths(cwd);
  const handlerDir = path.join(paths.handlersDir, stateName);
  const handlerPath = path.join(handlerDir, 'index.ts');

  if (fs.existsSync(handlerPath)) {
    console.log(`‚è≠Ô∏è  Handler already exists: src/handlers/${stateName}/index.ts`);
    return;
  }

  if (!fs.existsSync(handlerDir)) {
    fs.mkdirSync(handlerDir, { recursive: true });
  }

  const templateContent = fs.readFileSync(paths.templatePath, 'utf-8');
  const content = ejs.render(templateContent, {
    stateName,
    transitionStates: [...transitionStates].sort(),
    pascalCase,
  });

  fs.writeFileSync(handlerPath, content);
  console.log(`üìù Created: src/handlers/${stateName}/index.ts`);
}

function updateHandlersIndex(stateName: string, cwd: string): void {
  const paths = getProjectPaths(cwd);
  const indexPath = path.join(paths.handlersDir, 'index.ts');

  if (!fs.existsSync(indexPath)) {
    const content = `/**
 * State Handlers Index
 *
 * Import all your state handler files here.
 */

import './${stateName}/index.js';
`;
    fs.writeFileSync(indexPath, content);
    console.log(`üìù Created: src/handlers/index.ts`);
    return;
  }

  let content = fs.readFileSync(indexPath, 'utf-8');
  const importLine = `import './${stateName}/index.js';`;

  if (content.includes(importLine)) {
    return;
  }

  // Add import at the end
  content = content.trimEnd() + `\n${importLine}\n`;
  fs.writeFileSync(indexPath, content);
  console.log(`üìù Updated: src/handlers/index.ts`);
}

function removeFromHandlersIndex(stateName: string, cwd: string): void {
  const paths = getProjectPaths(cwd);
  const indexPath = path.join(paths.handlersDir, 'index.ts');

  if (!fs.existsSync(indexPath)) return;

  let content = fs.readFileSync(indexPath, 'utf-8');
  const importLine = `import './${stateName}/index.js';`;

  if (content.includes(importLine)) {
    content = content.replace(
      new RegExp(`^${importLine.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\n?`, 'm'),
      ''
    );
    fs.writeFileSync(indexPath, content);
    console.log(`üìù Removed import from: src/handlers/index.ts`);
  }
}

// Commands

export async function stateAdd(stateName: string | undefined): Promise<void> {
  const cwd = process.cwd();

  if (!stateName) {
    console.error('‚ùå Error: State name is required');
    console.error('Usage: telemeister state:add <state-name>');
    process.exit(1);
  }

  if (!validateStateName(stateName)) {
    console.error(
      '‚ùå Error: State name must start with a letter and contain only letters, numbers, and underscores'
    );
    process.exit(1);
  }

  const config = loadBotConfig(cwd);

  if (config[stateName]) {
    console.error(`‚ùå Error: State "${stateName}" already exists in bot.json`);
    process.exit(1);
  }

  // Add state to config
  config[stateName] = [];
  saveBotConfig(config, cwd);
  console.log(`‚úÖ Added state "${stateName}" to bot.json`);

  // Create handler
  await createHandler(stateName, [], cwd);
  updateHandlersIndex(stateName, cwd);

  // Sync types
  const paths = getProjectPaths(cwd);
  const typesContent = generateTypes(config);
  fs.writeFileSync(paths.stateTypesPath, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Generate diagram
  await generateDiagram(config, cwd);

  console.log(`\n‚úÖ State "${stateName}" added successfully!`);
  console.log(`\nNext steps:`);
  console.log(`  1. Edit src/handlers/${stateName}/index.ts to customize the handler`);
  console.log(`  2. Add transitions: telemeister state:transition:add ${stateName} <target-state>`);
}

export async function stateDelete(stateName: string | undefined): Promise<void> {
  const cwd = process.cwd();

  if (!stateName) {
    console.error('‚ùå Error: State name is required');
    console.error('Usage: telemeister state:delete <state-name>');
    process.exit(1);
  }

  const config = loadBotConfig(cwd);

  if (!config[stateName]) {
    console.error(`‚ùå Error: State "${stateName}" does not exist in bot.json`);
    process.exit(1);
  }

  // Safety check: non-empty handler folder
  if (isHandlerFolderNonEmpty(stateName, cwd)) {
    console.error(`‚ùå Error: Cannot delete state "${stateName}" - handler folder is not empty`);
    console.error(`   Path: src/handlers/${stateName}/`);
    console.error(`   Remove or move the handler files first, then retry.`);
    process.exit(1);
  }

  // Safety check: outgoing transitions
  const outgoing = config[stateName] || [];
  if (outgoing.length > 0) {
    console.error(`‚ùå Error: Cannot delete state "${stateName}" - has outgoing transitions:`);
    outgoing.forEach((t) => console.error(`   ${stateName} ‚Üí ${t}`));
    console.error(
      `   Remove transitions first: telemeister state:transition:delete ${stateName} <target>`
    );
    process.exit(1);
  }

  // Safety check: incoming transitions
  const incoming = getIncomingTransitions(config, stateName);
  if (incoming.length > 0) {
    console.error(`‚ùå Error: Cannot delete state "${stateName}" - has incoming transitions:`);
    incoming.forEach((f) => console.error(`   ${f} ‚Üí ${stateName}`));
    console.error(
      `   Remove transitions first: telemeister state:transition:delete <source> ${stateName}`
    );
    process.exit(1);
  }

  // Delete state
  delete config[stateName];
  saveBotConfig(config, cwd);
  console.log(`‚úÖ Removed state "${stateName}" from bot.json`);

  // Remove from handlers index
  removeFromHandlersIndex(stateName, cwd);

  // Sync types
  const paths = getProjectPaths(cwd);
  const typesContent = generateTypes(config);
  fs.writeFileSync(paths.stateTypesPath, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Generate diagram
  await generateDiagram(config, cwd);

  // Remove empty handler folder
  const handlerDir = path.join(paths.handlersDir, stateName);
  if (fs.existsSync(handlerDir)) {
    fs.rmdirSync(handlerDir);
    console.log(`üóëÔ∏è  Removed empty folder: src/handlers/${stateName}/`);
  }

  console.log(`\n‚úÖ State "${stateName}" deleted successfully!`);
}

export async function stateSync(): Promise<void> {
  const cwd = process.cwd();
  const config = loadBotConfig(cwd);
  const states = Object.keys(config);

  console.log('üîÑ Syncing state types and handlers...\n');

  // Generate types
  const paths = getProjectPaths(cwd);
  const typesContent = generateTypes(config);
  fs.writeFileSync(paths.stateTypesPath, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Create missing handlers
  for (const state of states) {
    if (!handlerExists(state, cwd)) {
      await createHandler(state, config[state] || [], cwd);
      updateHandlersIndex(state, cwd);
    } else {
      console.log(`‚è≠Ô∏è  Handler exists: src/handlers/${state}/index.ts`);
    }
  }

  // Generate diagram
  await generateDiagram(config, cwd);

  console.log('\n‚úÖ Sync complete!');
}

export async function transitionAdd(
  fromState: string | undefined,
  toState: string | undefined
): Promise<void> {
  const cwd = process.cwd();

  if (!fromState || !toState) {
    console.error('‚ùå Error: Both source and target state names are required');
    console.error('Usage: telemeister state:transition:add <from-state> <to-state>');
    process.exit(1);
  }

  const config = loadBotConfig(cwd);

  if (!config[fromState]) {
    console.error(`‚ùå Error: Source state "${fromState}" does not exist in bot.json`);
    process.exit(1);
  }

  if (!config[toState]) {
    console.error(`‚ùå Error: Target state "${toState}" does not exist in bot.json`);
    process.exit(1);
  }

  if (config[fromState].includes(toState)) {
    console.error(`‚ùå Error: Transition "${fromState}" ‚Üí "${toState}" already exists`);
    process.exit(1);
  }

  config[fromState].push(toState);
  saveBotConfig(config, cwd);
  console.log(`‚úÖ Added transition: ${fromState} ‚Üí ${toState}`);

  // Sync types
  const paths = getProjectPaths(cwd);
  const typesContent = generateTypes(config);
  fs.writeFileSync(paths.stateTypesPath, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Generate diagram
  await generateDiagram(config, cwd);
}

export async function transitionDelete(
  fromState: string | undefined,
  toState: string | undefined
): Promise<void> {
  const cwd = process.cwd();

  if (!fromState || !toState) {
    console.error('‚ùå Error: Both source and target state names are required');
    console.error('Usage: telemeister state:transition:delete <from-state> <to-state>');
    process.exit(1);
  }

  const config = loadBotConfig(cwd);

  if (!config[fromState]) {
    console.error(`‚ùå Error: Source state "${fromState}" does not exist in bot.json`);
    process.exit(1);
  }

  const index = config[fromState].indexOf(toState);
  if (index === -1) {
    console.error(`‚ùå Error: Transition "${fromState}" ‚Üí "${toState}" does not exist`);
    process.exit(1);
  }

  config[fromState].splice(index, 1);
  saveBotConfig(config, cwd);
  console.log(`‚úÖ Removed transition: ${fromState} ‚Üí ${toState}`);

  // Sync types
  const paths = getProjectPaths(cwd);
  const typesContent = generateTypes(config);
  fs.writeFileSync(paths.stateTypesPath, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Generate diagram
  await generateDiagram(config, cwd);
}

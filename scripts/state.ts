/**
 * State Management CLI
 *
 * Commands:
 *   state:add <name>              - Add a new state + create handler
 *   state:delete <name>           - Delete a state (with safety checks)
 *   state:sync                    - Sync types and create missing handlers
 *   state:transition:add <from> <to>    - Add a transition
 *   state:transition:delete <from> <to> - Delete a transition
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import ejs from 'ejs';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = path.join(__dirname, '..');
const SRC_DIR = path.join(ROOT_DIR, 'src');
const HANDLERS_DIR = path.join(SRC_DIR, 'handlers');
const BOT_JSON_PATH = path.join(SRC_DIR, 'bot.json');
const STATE_TYPES_PATH = path.join(SRC_DIR, 'bot-state-types.ts');
const BOT_DIAGRAM_MD_PATH = path.join(SRC_DIR, 'bot-diagram.md');
const BOT_DIAGRAM_PNG_PATH = path.join(SRC_DIR, 'bot-diagram.png');
const TEMPLATE_PATH = path.join(__dirname, 'templates', 'handler.ts.ejs');

type BotConfig = Record<string, string[]>;

function loadBotConfig(): BotConfig {
  if (!fs.existsSync(BOT_JSON_PATH)) {
    return {};
  }
  return JSON.parse(fs.readFileSync(BOT_JSON_PATH, 'utf-8'));
}

function saveBotConfig(config: BotConfig): void {
  fs.writeFileSync(BOT_JSON_PATH, JSON.stringify(config, null, 2) + '\n');
}

function validateStateName(name: string): boolean {
  return /^[a-zA-Z][a-zA-Z0-9_]*$/.test(name);
}

function pascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function getHandlerPath(stateName: string): string {
  return path.join(HANDLERS_DIR, stateName, 'index.ts');
}

function handlerExists(stateName: string): boolean {
  return fs.existsSync(getHandlerPath(stateName));
}

function isHandlerFolderNonEmpty(stateName: string): boolean {
  const handlerDir = path.join(HANDLERS_DIR, stateName);
  if (!fs.existsSync(handlerDir)) return false;
  const files = fs.readdirSync(handlerDir);
  return files.length > 0;
}

function getIncomingTransitions(config: BotConfig, stateName: string): string[] {
  const incoming: string[] = [];
  for (const [from, targets] of Object.entries(config)) {
    if (targets.includes(stateName)) {
      incoming.push(from);
    }
  }
  return incoming;
}

function generateTypes(config: BotConfig): string {
  const states = Object.keys(config).sort();

  if (states.length === 0) {
    return `// Auto-generated by state:sync - DO NOT EDIT
// No states defined yet

export type AppStates = never;

export type StateTransitions = Record<string, never>;
`;
  }

  const statesUnion = states.map((s) => `'${s}'`).join(' | ');

  let stateTransitionsContent = '';
  for (const state of states) {
    const targets = config[state] || [];
    if (targets.length === 0) {
      stateTransitionsContent += `  ${state}: void;\n`;
    } else {
      const targetsUnion = [...targets]
        .sort()
        .map((t) => `'${t}'`)
        .join(' | ');
      stateTransitionsContent += `  ${state}: ${targetsUnion} | void;\n`;
    }
  }

  let returnTypesContent = '';
  for (const state of states) {
    const typeName = `${pascalCase(state)}Transitions`;
    returnTypesContent += `export type ${typeName} = Promise<StateTransitions['${state}']>;\n`;
  }

  return `// Auto-generated by state:sync - DO NOT EDIT

export type AppStates = ${statesUnion};

export type StateTransitions = {
${stateTransitionsContent}};

${returnTypesContent}
`;
}

function generateMermaidDiagram(config: BotConfig): string {
  const states = Object.keys(config);

  if (states.length === 0) {
    return 'stateDiagram-v2\n    [*] --> [*]';
  }

  const transitions: string[] = [];
  for (const [from, targets] of Object.entries(config)) {
    for (const to of targets) {
      transitions.push(`    ${from} --> ${to}`);
    }
  }

  return `stateDiagram-v2\n${transitions.join('\n')}`;
}

function generateMermaidMarkdown(config: BotConfig): string {
  const mermaidCode = generateMermaidDiagram(config);

  return `# Bot State Diagram

\`\`\`mermaid
${mermaidCode}
\`\`\`
`;
}

async function generateDiagram(config: BotConfig): Promise<void> {
  const mdContent = generateMermaidMarkdown(config);
  fs.writeFileSync(BOT_DIAGRAM_MD_PATH, mdContent);
  console.log(`üìù Updated: src/bot-diagram.md`);

  const mermaidCode = generateMermaidDiagram(config);
  const tempMmdPath = path.join(ROOT_DIR, '.temp-diagram.mmd');

  fs.writeFileSync(tempMmdPath, mermaidCode);

  try {
    const { execSync } = await import('child_process');
    execSync(`npx mmdc -i "${tempMmdPath}" -o "${BOT_DIAGRAM_PNG_PATH}" -b white`, {
      stdio: 'pipe',
      cwd: ROOT_DIR,
    });
    console.log(`üìù Updated: src/bot-diagram.png`);
  } catch {
    console.warn(`‚ö†Ô∏è  Could not generate PNG diagram (mermaid-cli may not be installed)`);
  } finally {
    fs.unlinkSync(tempMmdPath);
  }
}

function createHandler(stateName: string, transitionStates: string[]): void {
  const handlerDir = path.join(HANDLERS_DIR, stateName);
  const handlerPath = path.join(handlerDir, 'index.ts');

  if (fs.existsSync(handlerPath)) {
    console.log(`‚è≠Ô∏è  Handler already exists: src/handlers/${stateName}/index.ts`);
    return;
  }

  if (!fs.existsSync(handlerDir)) {
    fs.mkdirSync(handlerDir, { recursive: true });
  }

  const templateContent = fs.readFileSync(TEMPLATE_PATH, 'utf-8');
  const content = ejs.render(templateContent, {
    stateName,
    transitionStates: [...transitionStates].sort(),
    pascalCase,
  });

  fs.writeFileSync(handlerPath, content);
  console.log(`üìù Created: src/handlers/${stateName}/index.ts`);
}

function updateHandlersIndex(stateName: string): void {
  const indexPath = path.join(HANDLERS_DIR, 'index.ts');

  if (!fs.existsSync(indexPath)) {
    const content = `/**
 * State Handlers Index
 *
 * Import all your state handler files here.
 */

import './${stateName}/index.js';
`;
    fs.writeFileSync(indexPath, content);
    console.log(`üìù Created: src/handlers/index.ts`);
    return;
  }

  let content = fs.readFileSync(indexPath, 'utf-8');
  const importLine = `import './${stateName}/index.js';`;

  if (content.includes(importLine)) {
    return;
  }

  // Add import at the end
  content = content.trimEnd() + `\n${importLine}\n`;
  fs.writeFileSync(indexPath, content);
  console.log(`üìù Updated: src/handlers/index.ts`);
}

function removeFromHandlersIndex(stateName: string): void {
  const indexPath = path.join(HANDLERS_DIR, 'index.ts');

  if (!fs.existsSync(indexPath)) return;

  let content = fs.readFileSync(indexPath, 'utf-8');
  const importLine = `import './${stateName}/index.js';`;

  if (content.includes(importLine)) {
    content = content.replace(
      new RegExp(`^${importLine.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\n?`, 'm'),
      ''
    );
    fs.writeFileSync(indexPath, content);
    console.log(`üìù Removed import from: src/handlers/index.ts`);
  }
}

// Commands

async function cmdStateAdd(stateName: string): Promise<void> {
  if (!stateName) {
    console.error('‚ùå Error: State name is required');
    console.error('Usage: npm run state:add -- <state-name>');
    process.exit(1);
  }

  if (!validateStateName(stateName)) {
    console.error(
      '‚ùå Error: State name must start with a letter and contain only letters, numbers, and underscores'
    );
    process.exit(1);
  }

  const config = loadBotConfig();

  if (config[stateName]) {
    console.error(`‚ùå Error: State "${stateName}" already exists in bot.json`);
    process.exit(1);
  }

  // Add state to config
  config[stateName] = [];
  saveBotConfig(config);
  console.log(`‚úÖ Added state "${stateName}" to bot.json`);

  // Create handler
  createHandler(stateName, []);
  updateHandlersIndex(stateName);

  // Sync types
  const typesContent = generateTypes(config);
  fs.writeFileSync(STATE_TYPES_PATH, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Generate diagram
  await generateDiagram(config);

  console.log(`\n‚úÖ State "${stateName}" added successfully!`);
  console.log(`\nNext steps:`);
  console.log(`  1. Edit src/handlers/${stateName}/index.ts to customize the handler`);
  console.log(`  2. Add transitions: npm run state:transition:add -- ${stateName} <target-state>`);
}

async function cmdStateDelete(stateName: string): Promise<void> {
  if (!stateName) {
    console.error('‚ùå Error: State name is required');
    console.error('Usage: npm run state:delete -- <state-name>');
    process.exit(1);
  }

  const config = loadBotConfig();

  if (!config[stateName]) {
    console.error(`‚ùå Error: State "${stateName}" does not exist in bot.json`);
    process.exit(1);
  }

  // Safety check: non-empty handler folder
  if (isHandlerFolderNonEmpty(stateName)) {
    console.error(`‚ùå Error: Cannot delete state "${stateName}" - handler folder is not empty`);
    console.error(`   Path: src/handlers/${stateName}/`);
    console.error(`   Remove or move the handler files first, then retry.`);
    process.exit(1);
  }

  // Safety check: outgoing transitions
  const outgoing = config[stateName] || [];
  if (outgoing.length > 0) {
    console.error(`‚ùå Error: Cannot delete state "${stateName}" - has outgoing transitions:`);
    outgoing.forEach((t) => console.error(`   ${stateName} ‚Üí ${t}`));
    console.error(
      `   Remove transitions first: npm run state:transition:delete -- ${stateName} <target>`
    );
    process.exit(1);
  }

  // Safety check: incoming transitions
  const incoming = getIncomingTransitions(config, stateName);
  if (incoming.length > 0) {
    console.error(`‚ùå Error: Cannot delete state "${stateName}" - has incoming transitions:`);
    incoming.forEach((f) => console.error(`   ${f} ‚Üí ${stateName}`));
    console.error(
      `   Remove transitions first: npm run state:transition:delete -- <source> ${stateName}`
    );
    process.exit(1);
  }

  // Delete state
  delete config[stateName];
  saveBotConfig(config);
  console.log(`‚úÖ Removed state "${stateName}" from bot.json`);

  // Remove from handlers index
  removeFromHandlersIndex(stateName);

  // Sync types
  const typesContent = generateTypes(config);
  fs.writeFileSync(STATE_TYPES_PATH, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Generate diagram
  await generateDiagram(config);

  // Remove empty handler folder
  const handlerDir = path.join(HANDLERS_DIR, stateName);
  if (fs.existsSync(handlerDir)) {
    fs.rmdirSync(handlerDir);
    console.log(`üóëÔ∏è  Removed empty folder: src/handlers/${stateName}/`);
  }

  console.log(`\n‚úÖ State "${stateName}" deleted successfully!`);
}

async function cmdStateSync(): Promise<void> {
  const config = loadBotConfig();
  const states = Object.keys(config);

  console.log('üîÑ Syncing state types and handlers...\n');

  // Generate types
  const typesContent = generateTypes(config);
  fs.writeFileSync(STATE_TYPES_PATH, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Create missing handlers
  for (const state of states) {
    if (!handlerExists(state)) {
      createHandler(state, config[state] || []);
      updateHandlersIndex(state);
    } else {
      console.log(`‚è≠Ô∏è  Handler exists: src/handlers/${state}/index.ts`);
    }
  }

  // Generate diagram
  await generateDiagram(config);

  console.log('\n‚úÖ Sync complete!');
}

async function cmdTransitionAdd(fromState: string, toState: string): Promise<void> {
  if (!fromState || !toState) {
    console.error('‚ùå Error: Both source and target state names are required');
    console.error('Usage: npm run state:transition:add -- <from-state> <to-state>');
    process.exit(1);
  }

  const config = loadBotConfig();

  if (!config[fromState]) {
    console.error(`‚ùå Error: Source state "${fromState}" does not exist in bot.json`);
    process.exit(1);
  }

  if (!config[toState]) {
    console.error(`‚ùå Error: Target state "${toState}" does not exist in bot.json`);
    process.exit(1);
  }

  if (config[fromState].includes(toState)) {
    console.error(`‚ùå Error: Transition "${fromState}" ‚Üí "${toState}" already exists`);
    process.exit(1);
  }

  config[fromState].push(toState);
  saveBotConfig(config);
  console.log(`‚úÖ Added transition: ${fromState} ‚Üí ${toState}`);

  // Sync types
  const typesContent = generateTypes(config);
  fs.writeFileSync(STATE_TYPES_PATH, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Generate diagram
  await generateDiagram(config);
}

async function cmdTransitionDelete(fromState: string, toState: string): Promise<void> {
  if (!fromState || !toState) {
    console.error('‚ùå Error: Both source and target state names are required');
    console.error('Usage: npm run state:transition:delete -- <from-state> <to-state>');
    process.exit(1);
  }

  const config = loadBotConfig();

  if (!config[fromState]) {
    console.error(`‚ùå Error: Source state "${fromState}" does not exist in bot.json`);
    process.exit(1);
  }

  const index = config[fromState].indexOf(toState);
  if (index === -1) {
    console.error(`‚ùå Error: Transition "${fromState}" ‚Üí "${toState}" does not exist`);
    process.exit(1);
  }

  config[fromState].splice(index, 1);
  saveBotConfig(config);
  console.log(`‚úÖ Removed transition: ${fromState} ‚Üí ${toState}`);

  // Sync types
  const typesContent = generateTypes(config);
  fs.writeFileSync(STATE_TYPES_PATH, typesContent);
  console.log(`üìù Updated: src/bot-state-types.ts`);

  // Generate diagram
  await generateDiagram(config);
}

// Main CLI
const command = process.argv[2];
const arg1 = process.argv[3];
const arg2 = process.argv[4];

async function main(): Promise<void> {
  switch (command) {
    case 'state:add':
      await cmdStateAdd(arg1);
      break;
    case 'state:delete':
      await cmdStateDelete(arg1);
      break;
    case 'state:sync':
      await cmdStateSync();
      break;
    case 'state:transition:add':
      await cmdTransitionAdd(arg1, arg2);
      break;
    case 'state:transition:delete':
      await cmdTransitionDelete(arg1, arg2);
      break;
    default:
      console.error('‚ùå Unknown command:', command);
      console.error('');
      console.error('Available commands:');
      console.error('  state:add <name>');
      console.error('  state:delete <name>');
      console.error('  state:sync');
      console.error('  state:transition:add <from> <to>');
      console.error('  state:transition:delete <from> <to>');
      process.exit(1);
  }
}

main().catch((err) => {
  console.error('‚ùå Error:', err.message);
  process.exit(1);
});
